pipeline {
    agent any

    options {
        timestamps()
    }

    parameters {
        booleanParam(
            name: 'FORCE_DEPLOY',
            defaultValue: false,
            description: 'Force deployment even if no changes detected'
        )
    }

    environment {
        GCP_SA_KEY = "abc"
    }

    stages {

        stage('Init') {
            steps {
                script {
                    echo "Branch name: ${env.BRANCH_NAME}"
                    echo "Commit: ${env.GIT_COMMIT}"

                    env.IMAGE_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT.take(7)}"

                    if (env.BRANCH_NAME in ['prod', 'main']) {
                        env.ENV_FILE   = 'Jenkins/prod.env'
                        env.TARGET_ENV = 'PROD'
                    } else if (env.BRANCH_NAME in ['dev', 'uat']) {
                        env.ENV_FILE   = 'Jenkins/dev.env'
                        env.TARGET_ENV = 'DEV'
                    } else {
                        error("‚ùå Unsupported branch: ${env.BRANCH_NAME}")
                    }

                    echo "Target environment: ${env.TARGET_ENV}"
                    echo "Using env file: ${env.ENV_FILE}"
                }
            }
        }

        stage('Detect Changes') {
            steps {
                script {
                    if (!fileExists(env.ENV_FILE)) {
                        error("‚ùå ${env.ENV_FILE} not found in repo")
                    }

                    // Read file LOCALLY (not env)
                    def envContent = readFile(env.ENV_FILE)

                    def envMap = [:]

                    envContent.split('\n').each { line ->
                        line = line.trim()
                        if (!line || line.startsWith('#')) return

                        def parts = line.split('=', 2)
                        envMap.put(parts[0], parts[1])
                    }

                    withEnv(envMap.collect { k, v -> "${k}=${v}" }) {

                        def deployments = []

                        env.each { k, v ->
                            if (k.startsWith('DEPLOY_') && k.endsWith('_PATH')) {
                                deployments << k.replace('DEPLOY_', '').replace('_PATH', '')
                            }
                        }

                        def changed = []

                        deployments.each { name ->
                            def path = env["DEPLOY_${name}_PATH"]

                            def diff = sh(
                                script: "git diff HEAD~1 HEAD --name-only | grep '^${path}' || true",
                                returnStdout: true
                            ).trim()

                            if (diff || params.FORCE_DEPLOY) {
                                changed << name
                            }
                        }

                        if (changed.isEmpty()) {
                            echo "‚ö†Ô∏è No changes detected"
                            env.SKIP_DEPLOY = 'true'
                        } else {
                            env.CHANGED_DEPLOYS = changed.join(',')
                            echo "Components to deploy: ${env.CHANGED_DEPLOYS}"
                        }
                    }
                }
            }
        }


        stage('Deploy') {
            when {
                expression { env.SKIP_DEPLOY != 'true' }
            }
            steps {
                script {
                    def envMap = [:]

                    env.DYNAMIC_ENV.split('\n').each { line ->
                        line = line.trim()
                        if (!line || line.startsWith('#')) return
                        def (k, v) = line.split('=', 2)
                        envMap[k] = v
                    }

                    withEnv(envMap.collect { k, v -> "${k}=${v}" }) {

                        env.CHANGED_DEPLOYS.split(',').each { name ->
                            def type = env["DEPLOY_${name}_TYPE"]

                            if (type == 'GCS') {
                                deployToGCS(name)
                            } else if (type == 'CLOUDRUN') {
                                deployToCloudRun(name)
                            } else {
                                error("‚ùå Unknown DEPLOY type for ${name}")
                            }
                        }
                    }
                }
            }
        }
    }

    post {
        success {
            echo "üéâ Deployment successful for ${env.TARGET_ENV}"
        }
        failure {
            echo "‚ùå Deployment failed"
        }
        always {
            script {
                if (env.WORKSPACE) {
                    cleanWs()
                }
            }
        }
    }
}
