pipeline {
    agent any

    options {
        skipDefaultCheckout(true)
    }

    stages {

        /* -------------------- BRANCH GUARD -------------------- */
        stage('Validate Branch') {
            when {
                not {
                    anyOf {
                        branch 'dev'
                        branch 'prod'
                    }
                }
            }
            steps {
                error "‚ùå Pipeline allowed only for dev or prod branches"
            }
        }

        /* -------------------- CHECKOUT -------------------- */
        stage('Checkout') {
            when {
                anyOf {
                    branch 'dev'
                    branch 'prod'
                }
            }
            steps {
                checkout scm
            }
        }

        /* -------------------- LOAD ENV -------------------- */
        stage('Load Env Config') {
            when {
                anyOf {
                    branch 'dev'
                    branch 'prod'
                }
            }
            steps {
                script {
                    def envFile = (env.BRANCH_NAME == 'prod')
                        ? 'env/prod.env'
                        : 'env/dev.env'

                    sh """
                        set -a
                        source ${envFile}
                        set +a
                        env > full.env
                    """
                }
            }
        }

        /* -------------------- DETECT CHANGES -------------------- */
        stage('Detect Changes') {
            when {
                anyOf {
                    branch 'dev'
                    branch 'prod'
                }
            }
            steps {
                script {
                    def diff = sh(
                        script: "git diff --name-only HEAD~1 HEAD",
                        returnStdout: true
                    ).trim()

                    writeFile file: 'changed_files.txt', text: diff
                }
            }
        }

        /* -------------------- ROUTE & DEPLOY -------------------- */
        stage('Route & Deploy') {
            when {
                anyOf {
                    branch 'dev'
                    branch 'prod'
                }
            }
            steps {
                script {
                    sh """
                        source full.env

                        DEPLOYS=\$(env | grep '^DEPLOY_.*_PATH=' | sed 's/DEPLOY_//' | sed 's/_PATH=.*//')

                        for name in \$DEPLOYS; do
                          PATH_VAR="DEPLOY_\${name}_PATH"
                          TYPE_VAR="DEPLOY_\${name}_TYPE"

                          DEPLOY_PATH=\${!PATH_VAR}
                          DEPLOY_TYPE=\${!TYPE_VAR}

                          if grep -q "^\\\${DEPLOY_PATH}" changed_files.txt; then
                            echo "üîÅ Change detected in \$DEPLOY_PATH"

                            if [ "\$DEPLOY_TYPE" = "GCS" ]; then
                              BUCKET_VAR="DEPLOY_\${name}_GCS_BUCKET"
                              PREFIX_VAR="DEPLOY_\${name}_GCS_PREFIX"

                              gsutil -m rsync -r \$DEPLOY_PATH gs://\${!BUCKET_VAR}/\${!PREFIX_VAR}

                            elif [ "\$DEPLOY_TYPE" = "CLOUDRUN" ]; then
                              IMAGE_VAR="DEPLOY_\${name}_IMAGE"
                              SERVICE_VAR="DEPLOY_\${name}_SERVICE"

                              gcloud auth configure-docker ${REGION}-docker.pkg.dev

                              docker build -t ${REGION}-docker.pkg.dev/${PROJECT_ID}/${ARTIFACT_REPO}/\${!IMAGE_VAR}:latest \$DEPLOY_PATH
                              docker push ${REGION}-docker.pkg.dev/${PROJECT_ID}/${ARTIFACT_REPO}/\${!IMAGE_VAR}:latest

                              gcloud run deploy \${!SERVICE_VAR} \
                                --image ${REGION}-docker.pkg.dev/${PROJECT_ID}/${ARTIFACT_REPO}/\${!IMAGE_VAR}:latest \
                                --region ${REGION} \
                                --platform managed \
                                --allow-unauthenticated
                            fi
                          fi
                        done
                    """
                }
            }
        }
    }
}
